Relatively recent developments in supercomputer nodes such as increasing physical and virtual core counts per node aim to speed up HPC application execution time. However, not all applications benefit from increased thread level parallelism. Additionally, the best performing thread count may not be known apriori as it can vary with application or with input size for a given application. This motivates the need for dynamically tuning the number of threads or cores used by an application, at run-time. However, such tuning of core counts in popular object-based or task-based runtime system is non-trivial since objects or tasks are anchored to processing elements (PEs) for locality. In this work, we identify the steps for adaptive tuning of core count to the most performant configuration, at run-time, for an object-based runtime system, Charm++. We show benefits of dynamic profiling and adaptively selecting core (physical or virtual) count for a variety of applications including compute, memory and cache-intensive applications. Specifically, we show that our mechanism can improve performance by 15\% in presence of memory contention, by 40\% when considering virtual cores, and by 25\% under a power-constrained setting, for proxy applications in Charm++.
